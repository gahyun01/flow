"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useUpdateNode.js":
/*!************************************!*\
  !*** ./src/hooks/useUpdateNode.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _flowbuilder_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/flowbuilder/Utils */ \"(app-pages-browser)/./src/flowbuilder/Utils.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ \"(app-pages-browser)/./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var reactflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! reactflow */ \"(app-pages-browser)/./node_modules/@reactflow/core/dist/esm/index.mjs\");\n//특정 노드와 엣지를 업데이트하거나 추가하는 역할\nvar _s = $RefreshSig$();\n\n\n\nfunction useUpdateNode() {\n    _s();\n    // ReactFlow에서 제공하는 setNodes와 setEdges 가져오기 (노드와 엣지 상태 업데이트용 함수)\n    const { setNodes, setEdges } = (0,reactflow__WEBPACK_IMPORTED_MODULE_2__.useReactFlow)();\n    // 노드를 업데이트하는 함수 정의\n    const handleSubmitNode = (data, currentNode)=>{\n        // 현재 노드의 타입이 \"Condition\"인 경우\n        if (currentNode.type === _flowbuilder_Utils__WEBPACK_IMPORTED_MODULE_0__.NodeTypes.Condition) {\n            const { conditions } = data;\n            // 새로 생성할 노드를 위한 조건 필터링 ( target이 정의되지 않은 경우 )\n            const creatableNew = conditions.filter((condition)=>condition.target === undefined);\n            const newNode = []; // 새로 추가될 노드를 저장할 배열\n            // 조건 중에서 step ID가 없는 항목에 대해\n            creatableNew.filter((item)=>!item.step.id) // step ID가 없는 조건만 필터링\n            .forEach((node)=>{\n                // 새로운 노드를 생성하여 newNode 배열에 추가\n                alert(\"노드를 생성해주세요.\");\n            });\n            // 기존 노드 상태 업데이트\n            setNodes((nodes)=>{\n                const clonedNodes = [\n                    ...nodes\n                ]; // 기존 노드 배열 복사\n                // 현재 노드를 찾아 데이터 업데이트\n                const maped = clonedNodes.map((item)=>{\n                    if (currentNode.id === item.id) {\n                        var _data_description;\n                        item.data.description = (_data_description = data === null || data === void 0 ? void 0 : data.description) !== null && _data_description !== void 0 ? _data_description : \"\"; // 새 설명 추가\n                        var _data_gotoStep;\n                        item.data.gotoStep = (_data_gotoStep = data === null || data === void 0 ? void 0 : data.gotoStep) !== null && _data_gotoStep !== void 0 ? _data_gotoStep : \"\"; // 이동할 스텝 정보 추가\n                        var _data_conditions;\n                        item.data.conditions = (_data_conditions = data === null || data === void 0 ? void 0 : data.conditions) !== null && _data_conditions !== void 0 ? _data_conditions : []; // 조건 정보 추가\n                        return item; // 업데이트된 노드 반환\n                    }\n                    return item; // 다른 노드는 그대로 반환\n                });\n                // 기존 노드 배열에 새로 생성된 노드 추가\n                const newEmbeddedNode = [\n                    ...maped,\n                    ...newNode\n                ];\n                return newEmbeddedNode; // 업데이트된 노드 배열 반환\n            });\n            // 엣지 상태 업데이트\n            setEdges((edges)=>{\n                const clonededges = [\n                    ...edges\n                ]; // 기존 엣지 배열 복사\n                // 새로운 엣지 생성\n                const newEdge = creatableNew === null || creatableNew === void 0 ? void 0 : creatableNew.map((item, index)=>{\n                    var _item_step, _item_step1;\n                    return (0,_flowbuilder_Utils__WEBPACK_IMPORTED_MODULE_0__.addNewEdge)(currentNode.id, (item === null || item === void 0 ? void 0 : (_item_step = item.step) === null || _item_step === void 0 ? void 0 : _item_step.id) ? item === null || item === void 0 ? void 0 : (_item_step1 = item.step) === null || _item_step1 === void 0 ? void 0 : _item_step1.id : newNode[index].id, \"custom\", item.value // 엣지의 조건 값\n                    );\n                });\n                // 기존 엣지 배열에 새 엣지 추가\n                const newUpdatedEdges = [\n                    ...clonededges,\n                    ...newEdge\n                ];\n                let uniqueArray = lodash__WEBPACK_IMPORTED_MODULE_1___default().uniqBy(newUpdatedEdges, \"id\"); // 중복 엣지 제거 (ID 기준)\n                // 기존 조건 데이터로 엣지를 업데이트\n                conditions.forEach((item)=>{\n                    const index = uniqueArray.findIndex((edge)=>edge.id === item.id); // 조건 ID에 해당하는 엣지 찾기\n                    if (index !== -1) {\n                        var _item_step, _item_step1;\n                        uniqueArray[index] = {\n                            ...uniqueArray[index],\n                            data: {\n                                id: item.id,\n                                condition: item.value,\n                                step: item.step\n                            },\n                            target: (item === null || item === void 0 ? void 0 : (_item_step = item.step) === null || _item_step === void 0 ? void 0 : _item_step.id) ? item === null || item === void 0 ? void 0 : (_item_step1 = item.step) === null || _item_step1 === void 0 ? void 0 : _item_step1.id : uniqueArray[index].target\n                        };\n                    }\n                });\n                return uniqueArray; // 업데이트된 엣지 배열 반환\n            });\n        } else {\n            setNodes((nodes)=>{\n                const clonedNodes = [\n                    ...nodes\n                ]; // 기존 노드 배열 복사\n                // 현재 노드를 찾아 데이터 업데이트\n                const maped = clonedNodes.map((item)=>{\n                    if (currentNode.id === item.id) {\n                        var _data_description;\n                        item.data.description = (_data_description = data === null || data === void 0 ? void 0 : data.description) !== null && _data_description !== void 0 ? _data_description : \"\"; // 새 설명 추가\n                        var _data_gotoStep;\n                        item.data.gotoStep = (_data_gotoStep = data === null || data === void 0 ? void 0 : data.gotoStep) !== null && _data_gotoStep !== void 0 ? _data_gotoStep : \"\"; // 이동할 스텝 정보 추가\n                        var _data_conditions;\n                        item.data.conditions = (_data_conditions = data === null || data === void 0 ? void 0 : data.conditions) !== null && _data_conditions !== void 0 ? _data_conditions : []; // 조건 정보 추가\n                        return item; // 업데이트된 노드 반환\n                    }\n                    return item; // 다른 노드는 그대로 반환\n                });\n                return maped; // 업데이트된 노드 배열 반환\n            });\n        }\n    };\n    return {\n        handleSubmitNode\n    };\n}\n_s(useUpdateNode, \"MBrh2SAdIrGFrxS2yrKqk+iA0hg=\", false, function() {\n    return [\n        reactflow__WEBPACK_IMPORTED_MODULE_2__.useReactFlow\n    ];\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useUpdateNode);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VVcGRhdGVOb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsNEJBQTRCOztBQUc0QztBQUNqRDtBQUNrQjtBQUV6QyxTQUFTSzs7SUFDUCxnRUFBZ0U7SUFDaEUsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRSxHQUFHSCx1REFBWUE7SUFFM0MsbUJBQW1CO0lBQ25CLE1BQU1JLG1CQUFtQixDQUFDQyxNQUFNQztRQUU5Qiw2QkFBNkI7UUFDN0IsSUFBSUEsWUFBWUMsSUFBSSxLQUFLWCx5REFBU0EsQ0FBQ1ksU0FBUyxFQUFFO1lBQzVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdKO1lBRXZCLDhDQUE4QztZQUM5QyxNQUFNSyxlQUFlRCxXQUFXRSxNQUFNLENBQ3BDLENBQUNDLFlBQWNBLFVBQVVDLE1BQU0sS0FBS0M7WUFHdEMsTUFBTUMsVUFBVSxFQUFFLEVBQUMsb0JBQW9CO1lBRXZDLDRCQUE0QjtZQUM1QkwsYUFDR0MsTUFBTSxDQUFDLENBQUNLLE9BQVMsQ0FBQ0EsS0FBS0MsSUFBSSxDQUFDQyxFQUFFLEVBQUcsc0JBQXNCO2FBQ3ZEQyxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ1IsOEJBQThCO2dCQUM5QkMsTUFBTTtZQUNSO1lBRUYsZ0JBQWdCO1lBQ2hCbkIsU0FBUyxDQUFDb0I7Z0JBQ1IsTUFBTUMsY0FBYzt1QkFBSUQ7aUJBQU0sRUFBRSxjQUFjO2dCQUU5QyxxQkFBcUI7Z0JBQ3JCLE1BQU1FLFFBQVFELFlBQVlFLEdBQUcsQ0FBQyxDQUFDVDtvQkFDN0IsSUFBSVYsWUFBWVksRUFBRSxLQUFLRixLQUFLRSxFQUFFLEVBQUU7NEJBQ05iO3dCQUF4QlcsS0FBS1gsSUFBSSxDQUFDcUIsV0FBVyxHQUFHckIsQ0FBQUEsb0JBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTXFCLFdBQVcsY0FBakJyQiwrQkFBQUEsb0JBQXFCLElBQUksVUFBVTs0QkFDdENBO3dCQUFyQlcsS0FB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QixJQUFJLGVBQWU7NEJBQ25DQTt3QkFBdkJXLEtBQUtYLElBQUksQ0FBQ0ksVUFBVSxHQUFHSixDQUFBQSxtQkFBQUEsaUJBQUFBLDJCQUFBQSxLQUFNSSxVQUFVLGNBQWhCSiw4QkFBQUEsbUJBQW9CLEVBQUUsRUFBRSxXQUFXO3dCQUMxRCxPQUFPVyxNQUFNLGNBQWM7b0JBQzdCO29CQUNBLE9BQU9BLE1BQU0sZ0JBQWdCO2dCQUMvQjtnQkFDQSxPQUFPUSxPQUFPLGlCQUFpQjtZQUNqQztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQUVwQjtJQUFpQjtBQUM1QjtHQXpHU0g7O1FBRXdCRCxtREFBWUE7OztBQXlHN0MsaUVBQWVDLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxmbG93XFxzcmNcXGhvb2tzXFx1c2VVcGRhdGVOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8v7Yq57KCVIOuFuOuTnOyZgCDsl6Psp4Drpbwg7JeF642w7J207Yq47ZWY6rGw64KYIOy2lOqwgO2VmOuKlCDsl63tlaBcblxuXG5pbXBvcnQgeyBOb2RlVHlwZXMsIGFkZE5ld0VkZ2UsIGFkZE5ld05vZGUgfSBmcm9tIFwiQC9mbG93YnVpbGRlci9VdGlsc1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgdXNlUmVhY3RGbG93IH0gZnJvbSBcInJlYWN0Zmxvd1wiO1xuXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlKCkge1xuICAvLyBSZWFjdEZsb3fsl5DshJwg7KCc6rO17ZWY64qUIHNldE5vZGVz7JmAIHNldEVkZ2VzIOqwgOyguOyYpOq4sCAo64W465Oc7JmAIOyXo+yngCDsg4Htg5wg7JeF642w7J207Yq47JqpIO2VqOyImClcbiAgY29uc3QgeyBzZXROb2Rlcywgc2V0RWRnZXMgfSA9IHVzZVJlYWN0RmxvdygpO1xuXG4gIC8vIOuFuOuTnOulvCDsl4XrjbDsnbTtirjtlZjripQg7ZWo7IiYIOygleydmFxuICBjb25zdCBoYW5kbGVTdWJtaXROb2RlID0gKGRhdGEsIGN1cnJlbnROb2RlKSA9PiB7XG5cbiAgICAvLyDtmITsnqwg64W465Oc7J2YIO2DgOyeheydtCBcIkNvbmRpdGlvblwi7J24IOqyveyasFxuICAgIGlmIChjdXJyZW50Tm9kZS50eXBlID09PSBOb2RlVHlwZXMuQ29uZGl0aW9uKSB7XG4gICAgICBjb25zdCB7IGNvbmRpdGlvbnMgfSA9IGRhdGE7XG5cbiAgICAgIC8vIOyDiOuhnCDsg53shLHtlaAg64W465Oc66W8IOychO2VnCDsobDqsbQg7ZWE7YSw66eBICggdGFyZ2V07J20IOygleydmOuQmOyngCDslYrsnYAg6rK97JqwIClcbiAgICAgIGNvbnN0IGNyZWF0YWJsZU5ldyA9IGNvbmRpdGlvbnMuZmlsdGVyKFxuICAgICAgICAoY29uZGl0aW9uKSA9PiBjb25kaXRpb24udGFyZ2V0ID09PSB1bmRlZmluZWRcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld05vZGUgPSBbXTsvLyDsg4jroZwg7LaU6rCA65CgIOuFuOuTnOulvCDsoIDsnqXtlaAg67Cw7Je0XG5cbiAgICAgIC8vIOyhsOqxtCDspJHsl5DshJwgc3RlcCBJROqwgCDsl4bripQg7ZWt66qp7JeQIOuMgO2VtFxuICAgICAgY3JlYXRhYmxlTmV3XG4gICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+ICFpdGVtLnN0ZXAuaWQpICAvLyBzdGVwIElE6rCAIOyXhuuKlCDsobDqsbTrp4wg7ZWE7YSw66eBXG4gICAgICAgIC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgLy8g7IOI66Gc7Jq0IOuFuOuTnOulvCDsg53shLHtlZjsl6wgbmV3Tm9kZSDrsLDsl7Tsl5Ag7LaU6rCAXG4gICAgICAgICAgYWxlcnQoXCLrhbjrk5zrpbwg7IOd7ISx7ZW07KO87IS47JqULlwiKVxuICAgICAgICB9KTtcblxuICAgICAgLy8g6riw7KG0IOuFuOuTnCDsg4Htg5wg7JeF642w7J207Yq4XG4gICAgICBzZXROb2Rlcygobm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgY2xvbmVkTm9kZXMgPSBbLi4ubm9kZXNdOyAvLyDquLDsobQg64W465OcIOuwsOyXtCDrs7XsgqxcblxuICAgICAgICAvLyDtmITsnqwg64W465Oc66W8IOywvuyVhCDrjbDsnbTthLAg7JeF642w7J207Yq4XG4gICAgICAgIGNvbnN0IG1hcGVkID0gY2xvbmVkTm9kZXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlkID09PSBpdGVtLmlkKSB7XG4gICAgICAgICAgICBpdGVtLmRhdGEuZGVzY3JpcHRpb24gPSBkYXRhPy5kZXNjcmlwdGlvbiA/PyBcIlwiOyAvLyDsg4gg7ISk66qFIOy2lOqwgFxuICAgICAgICAgICAgaXRlbS5kYXRhLmdvdG9TdGVwID0gZGF0YT8uZ290b1N0ZXAgPz8gXCJcIjsgLy8g7J2064+Z7ZWgIOyKpO2FnSDsoJXrs7Qg7LaU6rCAXG4gICAgICAgICAgICBpdGVtLmRhdGEuY29uZGl0aW9ucyA9IGRhdGE/LmNvbmRpdGlvbnMgPz8gW107IC8vIOyhsOqxtCDsoJXrs7Qg7LaU6rCAXG4gICAgICAgICAgICByZXR1cm4gaXRlbTsgLy8g7JeF642w7J207Yq465CcIOuFuOuTnCDrsJjtmZhcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZW07IC8vIOuLpOuluCDrhbjrk5zripQg6re464yA66GcIOuwmO2ZmFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyDquLDsobQg64W465OcIOuwsOyXtOyXkCDsg4jroZwg7IOd7ISx65CcIOuFuOuTnCDstpTqsIBcbiAgICAgICAgY29uc3QgbmV3RW1iZWRkZWROb2RlID0gWy4uLm1hcGVkLCAuLi5uZXdOb2RlXTtcbiAgICAgICAgcmV0dXJuIG5ld0VtYmVkZGVkTm9kZTsgLy8g7JeF642w7J207Yq465CcIOuFuOuTnCDrsLDsl7Qg67CY7ZmYXG4gICAgICB9KTtcblxuICAgICAgLy8g7Jej7KeAIOyDge2DnCDsl4XrjbDsnbTtirhcbiAgICAgIHNldEVkZ2VzKChlZGdlcykgPT4ge1xuICAgICAgICBjb25zdCBjbG9uZWRlZGdlcyA9IFsuLi5lZGdlc107IC8vIOq4sOyhtCDsl6Psp4Ag67Cw7Je0IOuzteyCrFxuXG4gICAgICAgIC8vIOyDiOuhnOyatCDsl6Psp4Ag7IOd7ISxXG4gICAgICAgIGNvbnN0IG5ld0VkZ2UgPSBjcmVhdGFibGVOZXc/Lm1hcCgoaXRlbSwgaW5kZXgpID0+XG4gICAgICAgICAgYWRkTmV3RWRnZShcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmlkLCAvLyDshozsiqQg64W465OcIElEXG4gICAgICAgICAgICBpdGVtPy5zdGVwPy5pZCA/IGl0ZW0/LnN0ZXA/LmlkIDogbmV3Tm9kZVtpbmRleF0uaWQsIC8vIO2DgOqynyDrhbjrk5wgSUQgKOyDiCDrhbjrk5wgSUQg7IKs7JqpKVxuICAgICAgICAgICAgXCJjdXN0b21cIiwgLy8g7Jej7KeAIO2DgOyehVxuICAgICAgICAgICAgaXRlbS52YWx1ZSAvLyDsl6Psp4DsnZgg7KGw6rG0IOqwklxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyDquLDsobQg7Jej7KeAIOuwsOyXtOyXkCDsg4gg7Jej7KeAIOy2lOqwgFxuICAgICAgICBjb25zdCBuZXdVcGRhdGVkRWRnZXMgPSBbLi4uY2xvbmVkZWRnZXMsIC4uLm5ld0VkZ2VdO1xuICAgICAgICBsZXQgdW5pcXVlQXJyYXkgPSBfLnVuaXFCeShuZXdVcGRhdGVkRWRnZXMsIFwiaWRcIik7ICAvLyDspJHrs7Ug7Jej7KeAIOygnOqxsCAoSUQg6riw7KSAKVxuXG4gICAgICAgIC8vIOq4sOyhtCDsobDqsbQg642w7J207YSw66GcIOyXo+yngOulvCDsl4XrjbDsnbTtirhcbiAgICAgICAgY29uZGl0aW9ucy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB1bmlxdWVBcnJheS5maW5kSW5kZXgoKGVkZ2UpID0+IGVkZ2UuaWQgPT09IGl0ZW0uaWQpOyAgLy8g7KGw6rG0IElE7JeQIO2VtOuLue2VmOuKlCDsl6Psp4Ag7LC+6riwXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdW5pcXVlQXJyYXlbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAuLi51bmlxdWVBcnJheVtpbmRleF0sXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICAgICAgc3RlcDogaXRlbS5zdGVwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0YXJnZXQ6IGl0ZW0/LnN0ZXA/LmlkXG4gICAgICAgICAgICAgICAgPyBpdGVtPy5zdGVwPy5pZFxuICAgICAgICAgICAgICAgIDogdW5pcXVlQXJyYXlbaW5kZXhdLnRhcmdldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdW5pcXVlQXJyYXk7IC8vIOyXheuNsOydtO2KuOuQnCDsl6Psp4Ag67Cw7Je0IOuwmO2ZmFxuICAgICAgfSk7XG4gICAgfSBcblxuICAgIC8vIO2YhOyerCDrhbjrk5zsnZgg7YOA7J6F7J20IFwiQ29uZGl0aW9uXCLsnbQg7JWE64uMIOqyveyasCDsspjrpqxcbiAgICBlbHNlIHtcbiAgICAgIHNldE5vZGVzKChub2RlcykgPT4ge1xuICAgICAgICBjb25zdCBjbG9uZWROb2RlcyA9IFsuLi5ub2Rlc107IC8vIOq4sOyhtCDrhbjrk5wg67Cw7Je0IOuzteyCrFxuICAgICAgICAvLyDtmITsnqwg64W465Oc66W8IOywvuyVhCDrjbDsnbTthLAg7JeF642w7J207Yq4XG4gICAgICAgIGNvbnN0IG1hcGVkID0gY2xvbmVkTm9kZXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlkID09PSBpdGVtLmlkKSB7XG4gICAgICAgICAgICBpdGVtLmRhdGEuZGVzY3JpcHRpb24gPSBkYXRhPy5kZXNjcmlwdGlvbiA/PyBcIlwiOyAvLyDsg4gg7ISk66qFIOy2lOqwgFxuICAgICAgICAgICAgaXRlbS5kYXRhLmdvdG9TdGVwID0gZGF0YT8uZ290b1N0ZXAgPz8gXCJcIjsgLy8g7J2064+Z7ZWgIOyKpO2FnSDsoJXrs7Qg7LaU6rCAXG4gICAgICAgICAgICBpdGVtLmRhdGEuY29uZGl0aW9ucyA9IGRhdGE/LmNvbmRpdGlvbnMgPz8gW107IC8vIOyhsOqxtCDsoJXrs7Qg7LaU6rCAXG4gICAgICAgICAgICByZXR1cm4gaXRlbTsgLy8g7JeF642w7J207Yq465CcIOuFuOuTnCDrsJjtmZhcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZW07IC8vIOuLpOuluCDrhbjrk5zripQg6re464yA66GcIOuwmO2ZmFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcGVkOyAvLyDsl4XrjbDsnbTtirjrkJwg64W465OcIOuwsOyXtCDrsJjtmZhcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHsgaGFuZGxlU3VibWl0Tm9kZSB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VVcGRhdGVOb2RlO1xuIl0sIm5hbWVzIjpbIk5vZGVUeXBlcyIsImFkZE5ld0VkZ2UiLCJhZGROZXdOb2RlIiwiXyIsInVzZVJlYWN0RmxvdyIsInVzZVVwZGF0ZU5vZGUiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwiaGFuZGxlU3VibWl0Tm9kZSIsImRhdGEiLCJjdXJyZW50Tm9kZSIsInR5cGUiLCJDb25kaXRpb24iLCJjb25kaXRpb25zIiwiY3JlYXRhYmxlTmV3IiwiZmlsdGVyIiwiY29uZGl0aW9uIiwidGFyZ2V0IiwidW5kZWZpbmVkIiwibmV3Tm9kZSIsIml0ZW0iLCJzdGVwIiwiaWQiLCJmb3JFYWNoIiwibm9kZSIsImFsZXJ0Iiwibm9kZXMiLCJjbG9uZWROb2RlcyIsIm1hcGVkIiwibWFwIiwiZGVzY3JpcHRpb24iLCJnb3RvU3RlcCIsIm5ld0VtYmVkZGVkTm9kZSIsImVkZ2VzIiwiY2xvbmVkZWRnZXMiLCJuZXdFZGdlIiwiaW5kZXgiLCJ2YWx1ZSIsIm5ld1VwZGF0ZWRFZGdlcyIsInVuaXF1ZUFycmF5IiwidW5pcUJ5IiwiZmluZEluZGV4IiwiZWRnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useUpdateNode.js\n"));

/***/ })

});