"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useUpdateNode.js":
/*!************************************!*\
  !*** ./src/hooks/useUpdateNode.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _flowbuilder_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/flowbuilder/Utils */ \"(app-pages-browser)/./src/flowbuilder/Utils.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ \"(app-pages-browser)/./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var reactflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! reactflow */ \"(app-pages-browser)/./node_modules/@reactflow/core/dist/esm/index.mjs\");\n//특정 노드와 엣지를 업데이트하거나 추가하는 역할\nvar _s = $RefreshSig$();\n\n\n\nfunction useUpdateNode() {\n    _s();\n    // ReactFlow에서 제공하는 setNodes와 setEdges 가져오기 (노드와 엣지 상태 업데이트용 함수)\n    const { setNodes, setEdges } = (0,reactflow__WEBPACK_IMPORTED_MODULE_2__.useReactFlow)();\n    // 노드를 업데이트하는 함수 정의\n    const handleSubmitNode = (data, currentNode)=>{\n        // 현재 노드의 타입이 \"Condition\"인 경우\n        if (currentNode.type === _flowbuilder_Utils__WEBPACK_IMPORTED_MODULE_0__.NodeTypes.Condition) {\n            const { conditions } = data;\n            // 새로 생성할 노드를 위한 조건 필터링 ( target이 정의되지 않은 경우 )\n            const creatableNew = conditions.filter((condition)=>condition.target === undefined);\n            const newNode = []; // 새로 추가될 노드를 저장할 배열\n            // 조건 중에서 step ID가 없는 항목에 대해 새 노드 생성\n            creatableNew.filter((item)=>!item.step.id) // step ID가 없는 조건만 필터링\n            .forEach((node)=>{\n                // 새로운 노드를 생성하여 newNode 배열에 추가\n                // newNode.push(\n                //   addNewNode(\n                //     { type: NodeTypes.StepNode, label: \"Input\" }, // StepNode 타입으로 노드 생성\n                //     currentNode // 현재 노드를 부모 노드로 설정\n                //   )\n                // );\n                alert(\"노드를 생성해주세요.\");\n            });\n            // 기존 노드 상태 업데이트\n            setNodes((nodes)=>{\n                const clonedNodes = [\n                    ...nodes\n                ]; // 기존 노드 배열 복사\n                // 현재 노드를 찾아 데이터 업데이트\n                const maped = clonedNodes.map((item)=>{\n                    if (currentNode.id === item.id) {\n                        var _data_description;\n                        item.data.description = (_data_description = data === null || data === void 0 ? void 0 : data.description) !== null && _data_description !== void 0 ? _data_description : \"\"; // 새 설명 추가\n                        var _data_gotoStep;\n                        item.data.gotoStep = (_data_gotoStep = data === null || data === void 0 ? void 0 : data.gotoStep) !== null && _data_gotoStep !== void 0 ? _data_gotoStep : \"\"; // 이동할 스텝 정보 추가\n                        var _data_conditions;\n                        item.data.conditions = (_data_conditions = data === null || data === void 0 ? void 0 : data.conditions) !== null && _data_conditions !== void 0 ? _data_conditions : []; // 조건 정보 추가\n                        return item; // 업데이트된 노드 반환\n                    }\n                    return item; // 다른 노드는 그대로 반환\n                });\n                // 기존 노드 배열에 새로 생성된 노드 추가\n                const newEmbeddedNode = [\n                    ...maped,\n                    ...newNode\n                ];\n                return newEmbeddedNode; // 업데이트된 노드 배열 반환\n            });\n            // 엣지 상태 업데이트\n            setEdges((edges)=>{\n                const clonededges = [\n                    ...edges\n                ]; // 기존 엣지 배열 복사\n                // 새로운 엣지 생성\n                const newEdge = creatableNew === null || creatableNew === void 0 ? void 0 : creatableNew.map((item, index)=>{\n                    var _item_step, _item_step1;\n                    return (0,_flowbuilder_Utils__WEBPACK_IMPORTED_MODULE_0__.addNewEdge)(currentNode.id, (item === null || item === void 0 ? void 0 : (_item_step = item.step) === null || _item_step === void 0 ? void 0 : _item_step.id) ? item === null || item === void 0 ? void 0 : (_item_step1 = item.step) === null || _item_step1 === void 0 ? void 0 : _item_step1.id : newNode[index].id, \"custom\", item.value // 엣지의 조건 값\n                    );\n                });\n                // 기존 엣지 배열에 새 엣지 추가\n                const newUpdatedEdges = [\n                    ...clonededges,\n                    ...newEdge\n                ];\n                let uniqueArray = lodash__WEBPACK_IMPORTED_MODULE_1___default().uniqBy(newUpdatedEdges, \"id\"); // 중복 엣지 제거 (ID 기준)\n                // 기존 조건 데이터로 엣지를 업데이트\n                conditions.forEach((item)=>{\n                    const index = uniqueArray.findIndex((edge)=>edge.id === item.id); // 조건 ID에 해당하는 엣지 찾기\n                    if (index !== -1) {\n                        var _item_step, _item_step1;\n                        uniqueArray[index] = {\n                            ...uniqueArray[index],\n                            data: {\n                                id: item.id,\n                                condition: item.value,\n                                step: item.step\n                            },\n                            target: (item === null || item === void 0 ? void 0 : (_item_step = item.step) === null || _item_step === void 0 ? void 0 : _item_step.id) ? item === null || item === void 0 ? void 0 : (_item_step1 = item.step) === null || _item_step1 === void 0 ? void 0 : _item_step1.id : uniqueArray[index].target\n                        };\n                    }\n                });\n                return uniqueArray; // 업데이트된 엣지 배열 반환\n            });\n        } else {\n            setNodes((nodes)=>{\n                const clonedNodes = [\n                    ...nodes\n                ]; // 기존 노드 배열 복사\n                // 현재 노드를 찾아 데이터 업데이트\n                const maped = clonedNodes.map((item)=>{\n                    if (currentNode.id === item.id) {\n                        var _data_description;\n                        item.data.description = (_data_description = data === null || data === void 0 ? void 0 : data.description) !== null && _data_description !== void 0 ? _data_description : \"\"; // 새 설명 추가\n                        var _data_gotoStep;\n                        item.data.gotoStep = (_data_gotoStep = data === null || data === void 0 ? void 0 : data.gotoStep) !== null && _data_gotoStep !== void 0 ? _data_gotoStep : \"\"; // 이동할 스텝 정보 추가\n                        var _data_conditions;\n                        item.data.conditions = (_data_conditions = data === null || data === void 0 ? void 0 : data.conditions) !== null && _data_conditions !== void 0 ? _data_conditions : []; // 조건 정보 추가\n                        return item; // 업데이트된 노드 반환\n                    }\n                    return item; // 다른 노드는 그대로 반환\n                });\n                return maped; // 업데이트된 노드 배열 반환\n            });\n        }\n    };\n    return {\n        handleSubmitNode\n    };\n}\n_s(useUpdateNode, \"MBrh2SAdIrGFrxS2yrKqk+iA0hg=\", false, function() {\n    return [\n        reactflow__WEBPACK_IMPORTED_MODULE_2__.useReactFlow\n    ];\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useUpdateNode);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VVcGRhdGVOb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsNEJBQTRCOztBQUc0QztBQUNqRDtBQUNrQjtBQUV6QyxTQUFTSzs7SUFDUCxnRUFBZ0U7SUFDaEUsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRSxHQUFHSCx1REFBWUE7SUFFM0MsbUJBQW1CO0lBQ25CLE1BQU1JLG1CQUFtQixDQUFDQyxNQUFNQztRQUU5Qiw2QkFBNkI7UUFDN0IsSUFBSUEsWUFBWUMsSUFBSSxLQUFLWCx5REFBU0EsQ0FBQ1ksU0FBUyxFQUFFO1lBQzVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdKO1lBRXZCLDhDQUE4QztZQUM5QyxNQUFNSyxlQUFlRCxXQUFXRSxNQUFNLENBQ3BDLENBQUNDLFlBQWNBLFVBQVVDLE1BQU0sS0FBS0M7WUFHdEMsTUFBTUMsVUFBVSxFQUFFLEVBQUMsb0JBQW9CO1lBRXZDLG9DQUFvQztZQUNwQ0wsYUFDR0MsTUFBTSxDQUFDLENBQUNLLE9BQVMsQ0FBQ0EsS0FBS0MsSUFBSSxDQUFDQyxFQUFFLEVBQUcsc0JBQXNCO2FBQ3ZEQyxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ1IsOEJBQThCO2dCQUM5QixnQkFBZ0I7Z0JBQ2hCLGdCQUFnQjtnQkFDaEIsMkVBQTJFO2dCQUMzRSxzQ0FBc0M7Z0JBQ3RDLE1BQU07Z0JBQ04sS0FBSztnQkFFTEMsTUFBTTtZQUNSO1lBRUYsZ0JBQWdCO1lBQ2hCbkIsU0FBUyxDQUFDb0I7Z0JBQ1IsTUFBTUMsY0FBYzt1QkFBSUQ7aUJBQU0sRUFBRSxjQUFjO2dCQUU5QyxxQkFBcUI7Z0JBQ3JCLE1BQU1FLFFBQVFELFlBQVlFLEdBQUcsQ0FBQyxDQUFDVDtvQkFDN0IsSUFBSVYsWUFBWVksRUFBRSxLQUFLRixLQUFLRSxFQUFFLEVBQUU7NEJBQ05iO3dCQUF4QlcsS0FBS1gsSUFBSSxDQUFDcUIsV0FBVyxHQUFHckIsQ0FBQUEsb0JBQUFB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LENBQUNzQixRQUFRLEdBQUd0QixDQUFBQSxpQkFBQUEsaUJBQUFBLDJCQUFBQSxLQUFNc0IsUUFBUSxjQUFkdEIsNEJBQUFBLGlCQUFrQixJQUFJLGVBQWU7NEJBQ25DQTt3QkFBdkJXLEtBQUtYLElBQUksQ0FBQ0ksVUFBVSxHQUFHSixDQUFBQSxtQkFBQUEsaUJBQUFBLDJCQUFBQSxLQUFNSSxVQUFVLGNBQWhCSiw4QkFBQUEsbUJBQW9CLEVBQUUsRUFBRSxXQUFXO3dCQUMxRCxPQUFPVyxNQUFNLGNBQWM7b0JBQzdCO29CQUNBLE9BQU9BLE1BQU0sZ0JBQWdCO2dCQUMvQjtnQkFDQSxPQUFPUSxPQUFPLGlCQUFpQjtZQUNqQztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQUVwQjtJQUFpQjtBQUM1QjtHQWhIU0g7O1FBRXdCRCxtREFBWUE7OztBQWdIN0MsaUVBQWVDLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxmbG93XFxzcmNcXGhvb2tzXFx1c2VVcGRhdGVOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8v7Yq57KCVIOuFuOuTnOyZgCDsl6Psp4Drpbwg7JeF642w7J207Yq47ZWY6rGw64KYIOy2lOqwgO2VmOuKlCDsl63tlaBcblxuXG5pbXBvcnQgeyBOb2RlVHlwZXMsIGFkZE5ld0VkZ2UsIGFkZE5ld05vZGUgfSBmcm9tIFwiQC9mbG93YnVpbGRlci9VdGlsc1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgdXNlUmVhY3RGbG93IH0gZnJvbSBcInJlYWN0Zmxvd1wiO1xuXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlKCkge1xuICAvLyBSZWFjdEZsb3fsl5DshJwg7KCc6rO17ZWY64qUIHNldE5vZGVz7JmAIHNldEVkZ2VzIOqwgOyguOyYpOq4sCAo64W465Oc7JmAIOyXo+yngCDsg4Htg5wg7JeF642w7J207Yq47JqpIO2VqOyImClcbiAgY29uc3QgeyBzZXROb2Rlcywgc2V0RWRnZXMgfSA9IHVzZVJlYWN0RmxvdygpO1xuXG4gIC8vIOuFuOuTnOulvCDsl4XrjbDsnbTtirjtlZjripQg7ZWo7IiYIOygleydmFxuICBjb25zdCBoYW5kbGVTdWJtaXROb2RlID0gKGRhdGEsIGN1cnJlbnROb2RlKSA9PiB7XG5cbiAgICAvLyDtmITsnqwg64W465Oc7J2YIO2DgOyeheydtCBcIkNvbmRpdGlvblwi7J24IOqyveyasFxuICAgIGlmIChjdXJyZW50Tm9kZS50eXBlID09PSBOb2RlVHlwZXMuQ29uZGl0aW9uKSB7XG4gICAgICBjb25zdCB7IGNvbmRpdGlvbnMgfSA9IGRhdGE7XG5cbiAgICAgIC8vIOyDiOuhnCDsg53shLHtlaAg64W465Oc66W8IOychO2VnCDsobDqsbQg7ZWE7YSw66eBICggdGFyZ2V07J20IOygleydmOuQmOyngCDslYrsnYAg6rK97JqwIClcbiAgICAgIGNvbnN0IGNyZWF0YWJsZU5ldyA9IGNvbmRpdGlvbnMuZmlsdGVyKFxuICAgICAgICAoY29uZGl0aW9uKSA9PiBjb25kaXRpb24udGFyZ2V0ID09PSB1bmRlZmluZWRcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld05vZGUgPSBbXTsvLyDsg4jroZwg7LaU6rCA65CgIOuFuOuTnOulvCDsoIDsnqXtlaAg67Cw7Je0XG5cbiAgICAgIC8vIOyhsOqxtCDspJHsl5DshJwgc3RlcCBJROqwgCDsl4bripQg7ZWt66qp7JeQIOuMgO2VtCDsg4gg64W465OcIOyDneyEsVxuICAgICAgY3JlYXRhYmxlTmV3XG4gICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+ICFpdGVtLnN0ZXAuaWQpICAvLyBzdGVwIElE6rCAIOyXhuuKlCDsobDqsbTrp4wg7ZWE7YSw66eBXG4gICAgICAgIC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgLy8g7IOI66Gc7Jq0IOuFuOuTnOulvCDsg53shLHtlZjsl6wgbmV3Tm9kZSDrsLDsl7Tsl5Ag7LaU6rCAXG4gICAgICAgICAgLy8gbmV3Tm9kZS5wdXNoKFxuICAgICAgICAgIC8vICAgYWRkTmV3Tm9kZShcbiAgICAgICAgICAvLyAgICAgeyB0eXBlOiBOb2RlVHlwZXMuU3RlcE5vZGUsIGxhYmVsOiBcIklucHV0XCIgfSwgLy8gU3RlcE5vZGUg7YOA7J6F7Jy866GcIOuFuOuTnCDsg53shLFcbiAgICAgICAgICAvLyAgICAgY3VycmVudE5vZGUgLy8g7ZiE7J6sIOuFuOuTnOulvCDrtoDrqqgg64W465Oc66GcIOyEpOyglVxuICAgICAgICAgIC8vICAgKVxuICAgICAgICAgIC8vICk7XG5cbiAgICAgICAgICBhbGVydChcIuuFuOuTnOulvCDsg53shLHtlbTso7zshLjsmpQuXCIpXG4gICAgICAgIH0pO1xuXG4gICAgICAvLyDquLDsobQg64W465OcIOyDge2DnCDsl4XrjbDsnbTtirhcbiAgICAgIHNldE5vZGVzKChub2RlcykgPT4ge1xuICAgICAgICBjb25zdCBjbG9uZWROb2RlcyA9IFsuLi5ub2Rlc107IC8vIOq4sOyhtCDrhbjrk5wg67Cw7Je0IOuzteyCrFxuXG4gICAgICAgIC8vIO2YhOyerCDrhbjrk5zrpbwg7LC+7JWEIOuNsOydtO2EsCDsl4XrjbDsnbTtirhcbiAgICAgICAgY29uc3QgbWFwZWQgPSBjbG9uZWROb2Rlcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaWQgPT09IGl0ZW0uaWQpIHtcbiAgICAgICAgICAgIGl0ZW0uZGF0YS5kZXNjcmlwdGlvbiA9IGRhdGE/LmRlc2NyaXB0aW9uID8/IFwiXCI7IC8vIOyDiCDshKTrqoUg7LaU6rCAXG4gICAgICAgICAgICBpdGVtLmRhdGEuZ290b1N0ZXAgPSBkYXRhPy5nb3RvU3RlcCA/PyBcIlwiOyAvLyDsnbTrj5ntlaAg7Iqk7YWdIOygleuztCDstpTqsIBcbiAgICAgICAgICAgIGl0ZW0uZGF0YS5jb25kaXRpb25zID0gZGF0YT8uY29uZGl0aW9ucyA/PyBbXTsgLy8g7KGw6rG0IOygleuztCDstpTqsIBcbiAgICAgICAgICAgIHJldHVybiBpdGVtOyAvLyDsl4XrjbDsnbTtirjrkJwg64W465OcIOuwmO2ZmFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlbTsgLy8g64uk66W4IOuFuOuTnOuKlCDqt7jrjIDroZwg67CY7ZmYXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIOq4sOyhtCDrhbjrk5wg67Cw7Je07JeQIOyDiOuhnCDsg53shLHrkJwg64W465OcIOy2lOqwgFxuICAgICAgICBjb25zdCBuZXdFbWJlZGRlZE5vZGUgPSBbLi4ubWFwZWQsIC4uLm5ld05vZGVdO1xuICAgICAgICByZXR1cm4gbmV3RW1iZWRkZWROb2RlOyAvLyDsl4XrjbDsnbTtirjrkJwg64W465OcIOuwsOyXtCDrsJjtmZhcbiAgICAgIH0pO1xuXG4gICAgICAvLyDsl6Psp4Ag7IOB7YOcIOyXheuNsOydtO2KuFxuICAgICAgc2V0RWRnZXMoKGVkZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb25lZGVkZ2VzID0gWy4uLmVkZ2VzXTsgLy8g6riw7KG0IOyXo+yngCDrsLDsl7Qg67O17IKsXG5cbiAgICAgICAgLy8g7IOI66Gc7Jq0IOyXo+yngCDsg53shLFcbiAgICAgICAgY29uc3QgbmV3RWRnZSA9IGNyZWF0YWJsZU5ldz8ubWFwKChpdGVtLCBpbmRleCkgPT5cbiAgICAgICAgICBhZGROZXdFZGdlKFxuICAgICAgICAgICAgY3VycmVudE5vZGUuaWQsIC8vIOyGjOyKpCDrhbjrk5wgSURcbiAgICAgICAgICAgIGl0ZW0/LnN0ZXA/LmlkID8gaXRlbT8uc3RlcD8uaWQgOiBuZXdOb2RlW2luZGV4XS5pZCwgLy8g7YOA6rKfIOuFuOuTnCBJRCAo7IOIIOuFuOuTnCBJRCDsgqzsmqkpXG4gICAgICAgICAgICBcImN1c3RvbVwiLCAvLyDsl6Psp4Ag7YOA7J6FXG4gICAgICAgICAgICBpdGVtLnZhbHVlIC8vIOyXo+yngOydmCDsobDqsbQg6rCSXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIOq4sOyhtCDsl6Psp4Ag67Cw7Je07JeQIOyDiCDsl6Psp4Ag7LaU6rCAXG4gICAgICAgIGNvbnN0IG5ld1VwZGF0ZWRFZGdlcyA9IFsuLi5jbG9uZWRlZGdlcywgLi4ubmV3RWRnZV07XG4gICAgICAgIGxldCB1bmlxdWVBcnJheSA9IF8udW5pcUJ5KG5ld1VwZGF0ZWRFZGdlcywgXCJpZFwiKTsgIC8vIOykkeuztSDsl6Psp4Ag7KCc6rGwIChJRCDquLDspIApXG5cbiAgICAgICAgLy8g6riw7KG0IOyhsOqxtCDrjbDsnbTthLDroZwg7Jej7KeA66W8IOyXheuNsOydtO2KuFxuICAgICAgICBjb25kaXRpb25zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHVuaXF1ZUFycmF5LmZpbmRJbmRleCgoZWRnZSkgPT4gZWRnZS5pZCA9PT0gaXRlbS5pZCk7ICAvLyDsobDqsbQgSUTsl5Ag7ZW064u57ZWY64qUIOyXo+yngCDssL7quLBcbiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB1bmlxdWVBcnJheVtpbmRleF0gPSB7XG4gICAgICAgICAgICAgIC4uLnVuaXF1ZUFycmF5W2luZGV4XSxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogaXRlbS52YWx1ZSxcbiAgICAgICAgICAgICAgICBzdGVwOiBpdGVtLnN0ZXAsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRhcmdldDogaXRlbT8uc3RlcD8uaWRcbiAgICAgICAgICAgICAgICA/IGl0ZW0/LnN0ZXA/LmlkXG4gICAgICAgICAgICAgICAgOiB1bmlxdWVBcnJheVtpbmRleF0udGFyZ2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB1bmlxdWVBcnJheTsgLy8g7JeF642w7J207Yq465CcIOyXo+yngCDrsLDsl7Qg67CY7ZmYXG4gICAgICB9KTtcbiAgICB9IFxuXG4gICAgLy8g7ZiE7J6sIOuFuOuTnOydmCDtg4DsnoXsnbQgXCJDb25kaXRpb25cIuydtCDslYTri4wg6rK97JqwIOyymOumrFxuICAgIGVsc2Uge1xuICAgICAgc2V0Tm9kZXMoKG5vZGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGVzID0gWy4uLm5vZGVzXTsgLy8g6riw7KG0IOuFuOuTnCDrsLDsl7Qg67O17IKsXG4gICAgICAgIC8vIO2YhOyerCDrhbjrk5zrpbwg7LC+7JWEIOuNsOydtO2EsCDsl4XrjbDsnbTtirhcbiAgICAgICAgY29uc3QgbWFwZWQgPSBjbG9uZWROb2Rlcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaWQgPT09IGl0ZW0uaWQpIHtcbiAgICAgICAgICAgIGl0ZW0uZGF0YS5kZXNjcmlwdGlvbiA9IGRhdGE/LmRlc2NyaXB0aW9uID8/IFwiXCI7IC8vIOyDiCDshKTrqoUg7LaU6rCAXG4gICAgICAgICAgICBpdGVtLmRhdGEuZ290b1N0ZXAgPSBkYXRhPy5nb3RvU3RlcCA/PyBcIlwiOyAvLyDsnbTrj5ntlaAg7Iqk7YWdIOygleuztCDstpTqsIBcbiAgICAgICAgICAgIGl0ZW0uZGF0YS5jb25kaXRpb25zID0gZGF0YT8uY29uZGl0aW9ucyA/PyBbXTsgLy8g7KGw6rG0IOygleuztCDstpTqsIBcbiAgICAgICAgICAgIHJldHVybiBpdGVtOyAvLyDsl4XrjbDsnbTtirjrkJwg64W465OcIOuwmO2ZmFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlbTsgLy8g64uk66W4IOuFuOuTnOuKlCDqt7jrjIDroZwg67CY7ZmYXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFwZWQ7IC8vIOyXheuNsOydtO2KuOuQnCDrhbjrk5wg67Cw7Je0IOuwmO2ZmFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4geyBoYW5kbGVTdWJtaXROb2RlIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVVwZGF0ZU5vZGU7XG4iXSwibmFtZXMiOlsiTm9kZVR5cGVzIiwiYWRkTmV3RWRnZSIsImFkZE5ld05vZGUiLCJfIiwidXNlUmVhY3RGbG93IiwidXNlVXBkYXRlTm9kZSIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJoYW5kbGVTdWJtaXROb2RlIiwiZGF0YSIsImN1cnJlbnROb2RlIiwidHlwZSIsIkNvbmRpdGlvbiIsImNvbmRpdGlvbnMiLCJjcmVhdGFibGVOZXciLCJmaWx0ZXIiLCJjb25kaXRpb24iLCJ0YXJnZXQiLCJ1bmRlZmluZWQiLCJuZXdOb2RlIiwiaXRlbSIsInN0ZXAiLCJpZCIsImZvckVhY2giLCJub2RlIiwiYWxlcnQiLCJub2RlcyIsImNsb25lZE5vZGVzIiwibWFwZWQiLCJtYXAiLCJkZXNjcmlwdGlvbiIsImdvdG9TdGVwIiwibmV3RW1iZWRkZWROb2RlIiwiZWRnZXMiLCJjbG9uZWRlZGdlcyIsIm5ld0VkZ2UiLCJpbmRleCIsInZhbHVlIiwibmV3VXBkYXRlZEVkZ2VzIiwidW5pcXVlQXJyYXkiLCJ1bmlxQnkiLCJmaW5kSW5kZXgiLCJlZGdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useUpdateNode.js\n"));

/***/ })

});